---
- name: Build java application
  hosts: build
  tasks:
  - name: Build the application
    shell: ./gradlew clean build
    args:
      chdir: ..

- name: Deploy java application
  hosts: prod
  become: true
  vars:
    app_name: algorithm-service
    app_jar_name: algorithm-service.jar
    app_build_file_dir: ../algorithm-service/build/libs
    app_dest_file_dir: /app

  tasks:
  # TODO: Create new user that will be responsible for running the application
  - name: Ensure required packages are installed
    apt:
      name:
        - openjdk-11-jre-headless
        - apache2
      state: present

  - name: Ensure the directory to which we want to copy the jar file exists
    file:
      path: "{{ app_dest_file_dir }}"
      state: directory

  - name: Copy the application jar file from the manager node to the managed (prod) host
    copy:
      src: "{{ app_build_file_dir }}/{{ app_jar_name }}"
      dest: "{{ app_dest_file_dir }}/{{ app_jar_name }}"
      force: yes

  - name: Make the application jar file executable
    file:
      path: "{{ app_dest_file_dir }}/{{ app_jar_name }}"
      mode: u=rwx,g=rx,o=rx

  - name: Ensure systemd service file exists
    template:
      src: templates/systemd-template-file.service.j2
      dest: /etc/systemd/system/algorithm-serice.service
    notify: reload systemd

  - name: Ensure the application is started
    # TODO: use systemd instead of shell module, and run it as a (to be created) user instead of root
    shell: sudo systemctl start algorithm-serice

  - name: Ensure apache2 config file exists
    template:
      src: templates/apache.conf.j2
      dest: /etc/apache2/sites-available/000-default.conf

  - name: Enable apache2 service
    shell: sudo a2enmod proxy && sudo a2enmod proxy_http && sudo service apache2 restart

  handlers:
  - name: reload systemd
    command: systemctl daemon-reload

  - name: restart the apache2 deamon
    command: systemctl restart apache2

- name: Test if the deployed application works as expected
  hosts: localhost,prod # prod is needed here just to get its URL
  vars:
    prod_url: "{{ hostvars['algorithm-service']['ansible_facts']['default_ipv4']['address'] }}"
  tasks:
  - name: Test if content returned by /primes/10 endpoint is correct
    uri:
      url: "http://{{ prod_url }}/primes/10"
      method: GET
      return_content: yes
      status_code: 200
      body_format: json
    register: result
    failed_when: >
      result.json.Primes != [2,3,5,7]
      or
      result.json.Initial != 10
    when: ansible_host == 'localhost'

  - name: Test if correct amount of primes is returned when querying the first million prime numbers
    uri:
      url: "http://{{ prod_url }}/primes/1000000"
      method: GET
      return_content: yes
      status_code: 200
      body_format: json
    register: result
    failed_when: result.json.Primes | length != 78498
    when: ansible_host == 'localhost'

  - name: Test if correct amount of primes is returned when querying the first ten million prime numbers
    uri:
      url: "http://{{ prod_url }}/primes/10000000"
      method: GET
      return_content: yes
      status_code: 200
      body_format: json
      timeout: 120
    register: result
    failed_when: result.json.Primes | length != 664579
    when: ansible_host == 'localhost'

  - name: Test if the second time we query ten million prime numbers is relatively fast, indicating caching was used
    uri:
      url: "http://{{ prod_url }}/primes/10000000"
      method: GET
      return_content: yes
      status_code: 200
      body_format: json
      timeout: 1
    when: ansible_host == 'localhost'
